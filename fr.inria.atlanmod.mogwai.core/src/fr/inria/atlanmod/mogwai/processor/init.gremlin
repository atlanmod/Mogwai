/**
 * This script initializes the Mogwai-ATL Gremlin-based engine by adding mapping 
 * methods to Gremlin metaclasses.
 * <p>
 * This script is also responsible of the creation of new Gremlin steps, that can 
 * be used in the transformation to improve script readability and provide a level 
 * of abstraction between the transformation engine and the low-level
 * graph representation.
 * 
 * @author Gwendal DANIEL
 */

// TODO: this initialization script doesn't take into account the case where different mappings
// are used for input and output models. To handle this it would be necessary to duplicate all 
// the created methods to allow in/out calls.

// Put the mapping helper in a final variable to allow its access from closures
// mappingHelper instanceof ModelDatastore
final mIn  = mappingHelperIn;
final mOut = mappingHelperOut;

// gremlinHelper instanceof GremlinHelper
final t = gremlinHelper;


def log(String msg) {
	enableDebug = false;
	if(enableDebug) {
		println(msg);
	}
}

/*
 * Additional Graph methods
 */

// g.allOfType("myType");
Object.metaClass.allOfType = 
{ 
	String typeName -> 
		log("allOfType(" + typeName + ")"); 
		mIn.allOfTypePipeline(typeName); 
}

// g.allOfKind("myType");
Object.metaClass.allOfKind = 
{ 
	String typeName -> 
		log("allOfKind(" + typeName + ")"); 
		mIn.allOfKindPipeline(typeName);
}

/*
 * Additional Vertex methods 
 */

// v.getAtt("myAtt");
Object.metaClass.getAtt = 
{ 
	String attName -> 
		log("getAtt(" + attName + ")"); 
		mIn.getAtt(delegate, attName); 
}

// v.getParent();
Object.metaClass.getParent = 
{
	->
		log("getParent()");
		mIn.getParent(delegate);
}

// v.getRef("myRef");
Object.metaClass.getRef = 
{ 
	String refName, String oppositeName, boolean isContainer -> 
		log("getRef(" + refName + "," + oppositeName + "," + isContainer + ")"); 
		mIn.getRef(delegate, refName, oppositeName, isContainer); 
}

// v.setAtt("myAtt", value);
Object.metaClass.setAtt = 
{ 
	String attName, Object attValue -> 
		log("setAtt(" + attName + ", " + attValue + ")"); 
		mOut.setAtt(delegate, attName, attValue); 
}

// v1.setRef("myRef", v2, isContainment)
Object.metaClass.setRef =
{
	String refName, Vertex otherEnd, boolean isContainment ->
		log("setRef(" + refName + "," + otherEnd + "," + isContainement + ")");
		mIn.setRef(delegate, refName, otherEnd, isContainment);
}

// v1.removeRef("myRef", v2, isContainment)
Object.metaClass.removeRef = 
{
	String refName, Vertex otherEnd, boolean isContainment ->
		log("removeRef(" + refName + "," + otherEnd + "," + isContainment + ")");
		mIn.removeRef(delegate, refName, otherEnd, isContainment);
}

// v.getType();
Object.metaClass.getType = 
{
	-> 
		log("getType()");
		mIn.getType(delegate);
}

// v.isTypeOf("myType");
Object.metaClass.isTypeOf = 
{ 
	String type -> 
		log("isTypeOf(" + type + ")"); 
		mIn.isTypeOf(delegate, type); 
}

// v.isKindOf("myType");
Object.metaClass.isKindOf =
{
	String type ->
		log("isKindOf(" + type + ")");
		mIn.isKindOf(delegate, type);
}

/*
 * Additional Gremlin steps
 */

// Pipe.getAtt("myAtt");
Gremlin.defineStep("getAtt", [Pipe], 
	{
		String attName ->
			log("getAtt(" + attName + ")[Pipe]");
			mIn.getAtt(attName);
	}	
)

// Pipe.getParent()
Gremlin.defineStep("getParent", [Pipe],
	{
		->
			log("getParent()[Pipe]");
			mIn.getParent();
	}	
)

// Pipe.getRef("myRef");
Gremlin.defineStep("getRef", [Pipe], 
	{
		String refName, String oppositeName, boolean isContainer ->
			log("getRef(" + refName + "," + oppositeName + "," + isContainer + ")[Pipe]");
			mIn.getRef(refName, oppositeName, isContainer);
	}	
)

// Pipe.setAtt("myAtt", value);
Gremlin.defineStep("setAtt", [Pipe],
	{
		String attName, Object attValue ->
			log("setAtt(" + attName + "," + attValue + ")[Pipe]");
			mOut.setAtt(attName, attValue);
	}	
)

// Pipe.setRef("myRef", v, isContainment)
Gremlin.defineStep("setRef", [Pipe],
	{
		String refName, Vertex otherEnd, boolean isContainment ->
			log("setRef(" + refName + "," + otherEnd + "," + isContainment + ")[Pipe]");
			mIn.setRef(refName, otherEnd, isContainment);
	}	
)

// Pipe.removeRef("myRef", v, isContainment)
Gremlin.defineStep("removeRef", [Pipe],
	{
		String refName, Vertex otherEnd, boolean isContainment ->
			log("removeRef(" + refName + "," + otherEnd + "," + isContainment + ")[Pipe]");
			mIn.removeRef(refName, otherEnd, isContainment);
	}	
)
// Pipe.getType();
Gremlin.defineStep("getType", [Pipe], 
	{
		->
			log("getType()[Pipe]");
			mIn.getType();
	}	
)

// Pipe.isTypeOf("myType");
Gremlin.defineStep("isTypeOf", [Pipe],
	{
		String typeName ->
			log("isTypeOf(" + typeName + ")[Pipe]");
			mIn.isTypeOf(typeName);
	}	
)

// Pipe.isKindOf("myType");
Gremlin.defineStep("isKindOf", [Pipe], 
	{
		String typeName ->
			log("isKindOf(" + typeName + ")[Pipe]");
			mIn.isKindOf(typeName);
	}	
)

/*
 * Additional operations
 */

// [a,b,c].union([d,e,f]);
Iterable.metaClass.union = 
{
	Iterable right ->
		log("union");
		t.union(delegate, right);
}

// [a,b,c].intersection([d,e,f]);
Iterable.metaClass.intersection = 
{
	Iterable right ->
		log("intersection");
		t.intersection(delegate, right);
}

// [a,b,c].difference([d,e,f]);
Iterable.metaClass.difference = 
{
	Iterable right ->
		log("difference");
		t.difference(delegate, right);
}

Iterable.metaClass.getString = 
{
	->
		log("getString");
		Iterator i = delegate.iterator();
		String value = i.next().toString();
		log("getString result: " + value);
		if(i.hasNext()) {
			throw new IllegalStateException("Calling toString on an Iterable that contain more than one element");
		}
		value;
}

Iterable.metaClass.undefined = 
{
	->
		log("undefined");
		Iterator i = delegate.iterator();
		boolean result = true;
		if(i.hasNext()) {
			result = (i.next() == null);
		}
		result;
}
