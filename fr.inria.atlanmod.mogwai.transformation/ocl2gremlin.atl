-- @path OCL=http://www.eclipse.org/ocl/1.1.0/Ecore
-- @path Gremlin=/fr.inria.atlanmod.mogwai.gremlin/model/gremlin.ecore

-- OCL to Gremlin ATL Module

-- Transforms an OCL input model into its representation through the
-- Gremlin metamodel (see fr.inria.atlanmod.ocl2query.gremlin).
-- OCL models are reversed compare to the natural writing :
--		a->collect(b)->select(e | e.oclIsTypeOf(X))
--	produces a model like
--		select(collect(access(a)))
-- While Gremlin syntax and model are both organized in the natural writing 
-- order. The main objective of this transformation is to reverse OCL expression
-- chains to match them in prefixed order.
-- The typical matching is done in 2 parts :
--	- Find the highest object in the considered tree hierarchy
--  - Match this object to a step and associate next step to the container of the object

-- Author AtlanMod - Inria

module ocl2gremlin;

create OUT: Gremlin from IN: OCL;

uses common;

-- Returns all the expressions in the OCLExpression tree that
-- are allInstances() operations
helper context OCL!OCLExpression def : getTypeExps() : OrderedSet(OCL!TypeExp) =
	OCL!TypeExp.allInstances()->iterate(each; res : OrderedSet(OCL!TypeExp) = OrderedSet{} | 
		if(res->collect(e | e.referredType.name)->includes(each.referredType.name)) then
			res
		else
			res.append(each)
		endif)
	;
	
helper context OCL!OCLExpression def : isInCollect() : Boolean = 
	if self.refImmediateComposite().oclIsTypeOf(OCL!IteratorExp) then
		self.refImmediateComposite().name = 'collect'
	else
		self.refImmediateComposite().isInCollect()
	endif
	;



helper context OCL!OCLExpression def : getFirstInstructionCollectionOperation() : OCL!OCLExpression =
	if self.oclIsTypeOf(OCL!OperationCallExp) or self.oclIsTypeOf(OCL!IteratorExp) then
		if Set{'union','intersection'}.includes(self.getOpName()) then
			self
		else
			self.source.getFirstInstructionUnion()
		endif
	else
		if self.oclIsTypeOf(OCL!VariableExp) or
			self.oclIsKindOf(OCL!LiteralExp) or
			self.oclIsTypeOf(OCL!TypeExp) or
			self.oclIsKindOf(OCL!BooleanLiteralExp) then
			self
		else
			self.source.getFirstInstructionCollectionIntersection()
		endif
	endif
	;

helper context OCL!OCLExpression def : getFirstInstructionInCollectionOperations() : OrderedSet(OCL!OCLExpression) =
	if OCL!OperationCallExp.allInstances()->select(each | Set{'union','intersection'}.includes(each.getOpName())).size() = 0 then
--		self.getFirstInstruction() removed to avoid cast error if there is no union
		OrderedSet{}
	else
		thisModule.reverse(OCL!OperationCallExp.allInstances())->select(each | Set{'union','intersection'}.includes(each.getOpName()))->collect(e | OrderedSet{}.append(e.argument.first().getFirstInstructionCollectionOperation())).flatten()
	endif
	;

helper def : reverse(seq : Sequence(OclAny)): Sequence(OclAny) = seq->iterate(e; res : Sequence(OclAny) = Sequence{} | res.prepend(e));

helper context OCL!OCLExpression def : isLastInCollectionOperation() : Boolean =
	if self.refImmediateComposite().oclIsTypeOf(OCL!OperationCallExp) then
		if Sequence{'union','intersection'}.includes(self.refImmediateComposite().getOpName()) then
			true
		else
			false
		endif
	else
		false
	endif
	;

helper context OCL!OCLExpression def : isInCollectionOperationLeftPart() : Boolean =
	if self.isLastInCollectionOperation() then
		self.refImmediateComposite().source = self
	else
		false
	endif
	;

helper context OCL!OCLExpression def : getCollectionVariableName() : String =
	let res : String = 'collection' in
		if self.isInCollectionOperationLeftPart() then
			res + thisModule.getUnionIndex(self.refImmediateComposite()) + 'Left'
		else
			res + thisModule.getUnionIndex(self.refImmediateComposite()) + 'Right'
		endif
	;

helper context OCL!PropertyCallExp def : isLastInComparison() : Boolean =
	if self.refImmediateComposite().oclIsTypeOf(OCL!OperationCallExp) then
		self.refImmediateComposite().isComparison()
	else
		false
	endif
	;


	
-- Creates the Gremlin container (GremlinScript) from
-- the OCL container (Constraint)
-- Meta elements are computed first to generate appropriate variables (for type checking
-- and indices access).
-- The first instruction (i.e the last one in the OCL model) is then retrieved and added to the
-- instruction list.
rule constraint2script {
	from
		cc : OCL!Constraint
	to
		gg : Gremlin!GremlinScript (
			instructions <- cc.specification.bodyExpression.getTypeExps()
				->collect(e | thisModule.typeExp2meta(e)).union(
					cc.specification.bodyExpression.getTypeExps()
				->collect(e | thisModule.typeExp2metaNodes(e))).union(
					let collectionOperations : Sequence(OCL!OperationCallExp) = OCL!OperationCallExp.allInstances()->select(each | Set{'union','intersection'}.includes(each.getOpName())) in
					if collectionOperations.isEmpty() then
						OrderedSet{}
					else
						collectionOperations->collect(e | thisModule.collectionOperation2metaLeft(e)).union(
							collectionOperations->collect(e | thisModule.collectionOperation2metaRight(e))	
						)
						.append(
							if(collectionOperations->exists(e | e.getOpName() = 'union')) then
							thisModule.unionMetaMethod(collectionOperations.first())
							else
								OclUndefined
							endif
						).append(
							if(collectionOperations->exists(e | e.getOpName() = 'intersection')) then
							thisModule.intersectionMetaMethod(collectionOperations.first())
							else
								OclUndefined
							endif
						)
					endif).
				append(
					cc.specification.bodyExpression.getFirstInstruction()
				).
				union(
					cc.specification.bodyExpression.getFirstInstructionInCollectionOperations()
				).
				union(
					OCL!OperationCallExp.allInstances()->select(each | Set{'union','intersection'}.includes(each.getOpName()))	
				)
		)
}

-- Creates variables associated to allInstances calls to avoid multiple index
-- accesses in the same step.
-- @see allInstances2steps for generated steps.
lazy rule typeExp2meta {
	from
		typeExp : OCL!TypeExp
	to
		metaVar : Gremlin!VariableDeclaration (
			name <- 'meta'+typeExp.referredType.name,
			value <- metaStartStep
		),
		metaStartStep : Gremlin!StartStep (
			nextElement <- idxCall	
		),
		idxCall : Gremlin!IndexCall (
			indexName <- 'metaclasses',
			indexProperty  <- 'name',
			indexQuery <- typeExp.referredType.name
		)
}

-- Creates variables associated to oclIsTypeOf calls to avoid multiple index
-- accesses in the same step.
-- @see oclIsTypeOf2steps for generated steps.
lazy rule typeExp2metaNodes {
	from
		typeExp : OCL!TypeExp
	to
		metaVar : Gremlin!VariableDeclaration(
			name <- 'meta'+typeExp.referredType.name+'Node',
			value <- metaVarAccess
		),
		metaVarAccess : Gremlin!VariableAccess(
			name <- 'meta'+typeExp.referredType.name,
			nextElement <- nextIt
		),
		nextIt : Gremlin!NextCall ()
		
}

helper def : getUnionIndex(u : OCL!OperationCallExp) : Integer =
	OCL!OperationCallExp.allInstances()->select(each | each.getOpName() = 'union')->indexOf(u)
	;

lazy rule unionMetaMethod {
	from
		oclUnion : OCL!OperationCallExp
	to
		computeUnion : Gremlin!MethodDeclaration(
			name <- 'computeUnion',
			parameters <- Sequence{'c1','c2'},
			instructions <- Sequence{unionInstruction1,unionInstruction2}
		),
		unionInstruction1 : Gremlin!VariableAccess(
			name <- 'c1',
			nextElement <- unionAddAllCall
		),
		unionAddAllCall : Gremlin!AddAllCall(
			value <- unionV2	
		),
		unionV2 : Gremlin!VariableAccess(
			name <- 'c2'	
		),
		unionInstruction2 : Gremlin!VariableAccess(
			name <- 'c1'	
		)
}

lazy rule intersectionMetaMethod {
	from
		oclUnion : OCL!OperationCallExp
	to
		computeIntersection : Gremlin!MethodDeclaration(
			name <- 'computeIntersection',
			parameters <- Sequence{'c1','c2'},
			instructions <- Sequence{intersectionInstruction1,intersectionInstruction2}
		),
		intersectionInstruction1 : Gremlin!VariableAccess(
			name <- 'c1',
			nextElement <- intersectionRetainAllCall
		),
		intersectionRetainAllCall : Gremlin!RetainAllCall(
			value <- intersectionV2	
		),
		intersectionV2 : Gremlin!VariableAccess(
			name <- 'c2'	
		),
		intersectionInstruction2 : Gremlin!VariableAccess(
			name <- 'c1'	
		)
}

-- Create variables to store union parts
lazy rule collectionOperation2metaLeft {
	from
		oclUnion : OCL!OperationCallExp
	to
		metaUnionVar : Gremlin!VariableDeclaration (
			name <- 'collection' + thisModule.getUnionIndex(oclUnion) + 'Left',
			value <- col
		),
		col : Gremlin!CollectionDefinition ()
}

lazy rule collectionOperation2metaRight {
	from
		oclUnion : OCL!OperationCallExp
	to
		metaUnionVar : Gremlin!VariableDeclaration(
			name <- 'collection' + thisModule.getUnionIndex(oclUnion) + 'Right',
			value <- col
		),
		col : Gremlin!CollectionDefinition()
}

rule union2steps {
	from
		union : OCL!OperationCallExp (union.getOpName() = 'union')
	to
		uc : Gremlin!UnionCall(
			leftCollection <- vaL,
			rightCollection <- vaR,
			cast <- thisModule.lazyCol(union.eType),
			nextElement <- idStep
		),
		vaL : Gremlin!VariableAccess(
			name <- union.source.getCollectionVariableName()	
		),
		vaR : Gremlin!VariableAccess(
			name <- union.argument.first().getCollectionVariableName()	
		),
		idStep : Gremlin!IdentityStep(
			nextElement <- union.getComposite()	
		)
}

rule intersection2steps {
	from
		intersection : OCL!OperationCallExp (intersection.getOpName() = 'intersection')
	to
		ic : Gremlin!IntersectionCall(
			leftCollection <- vaL,
			rightCollection <- vaR,
			cast <- thisModule.lazyCol(intersection.eType),
			nextElement <- idStep
		),
		vaL : Gremlin!VariableAccess(
			name <- intersection.source.getCollectionVariableName()	
		),
		vaR : Gremlin!VariableAccess(
			name <- intersection.argument.first().getCollectionVariableName()	
		),
		idStep : Gremlin!IdentityStep(
			nextElement <- intersection.getComposite()	
		)
}

lazy rule lazyCol {
	from
		colType : OCL!CollectionType
	to
		decl : Gremlin!TypeDeclaration()
}

lazy rule lazySeq extends lazyCol {
	from
		colType : OCL!SequenceType
	to
		decl : Gremlin!ListDeclaration
}

lazy rule lazySet extends lazyCol {
	from
		colType : OCL!SetType
	to
		decl : Gremlin!SetDeclaration
}

lazy rule lazyOrderedSet extends lazyCol {
	from
		colType : OCL!OrderedSetType
	to
		decl : Gremlin!SortedSetDeclaration
}

lazy rule lazyBag extends lazyCol {
	from
		colType : OCL!BagType
	to
		decl : Gremlin!ListDeclaration
}
--rule union2steps {
--	from
--		oclUnion : OCL!OperationCallExp (oclUnion.getOpName() = 'union')
--	to
--		gg : Gremlin!VariableAccess(
--			name <- 'unionContent',
--			nextElement <- idStep
--		),
--		idStep : Gremlin!IdentityStep(
--			nextElement <- if oclUnion.getComposite().getOpName() = 'union' then
--							OclUndefined
--							else
--								oclUnion.getComposite()
--							endif
--		)
--}

-- Transforms 'allInstances' expressions into kyanosInstanceOf edge step
-- and vertex step.
--lazy rule allInstances2steps {
rule allInstances2steps {
	from
		allInstances : OCL!OperationCallExp (allInstances.getOpName() = 'allInstances')
	to
		ine : Gremlin!InEStep (
			relationshipName <- 'kyanosInstanceOf',
			nextElement <- outv
		),
		outv : Gremlin!OutVStep (
			nextElement <- allInstances.getComposite()
		)
}

rule typeExp2steps {
	from
		typeExp : OCL!TypeExp (
			if typeExp.refImmediateComposite().oclIsTypeOf(OCL!OperationCallExp) then
				not(typeExp.refImmediateComposite().getOpName() = 'oclAsType')
			else
				true
			endif
		)
	to
		vap : Gremlin!VariableAccess(
			name <- 'meta'+	typeExp.referredType.name+'Node',
			nextElement <- typeExp.getComposite()
		)
}

-- Transforms 'collect' expressions into edge and vertex step.
rule collect2steps {
	from 
		collect : OCL!IteratorExp (collect.getOpName() = 'collect' and not collect.isLastInCollectionOperation())
	to
		id : Gremlin!IdentityStep(
			nextElement <- collect.getComposite()
		)
}

rule collectLastInUnionRightPart2steps {
	from 
		collect : OCL!IteratorExp (collect.getOpName() = 'collect' and collect.isLastInCollectionOperation() and not collect.isInCollectionOperationLeftPart())
	to
		fill : Gremlin!FillStep(
			instruction <- unionContentVariableAccess
		),
		unionContentVariableAccess : Gremlin!VariableAccess (
			name <- 'unionContent'
		)
}

rule collectLastInUnionLeftPart2steps {
	from 
		collect : OCL!IteratorExp (collect.getOpName() = 'collect' and collect.isLastInCollectionOperation() and collect.isInCollectionOperationLeftPart())
	to
		fill : Gremlin!FillStep(
			instruction <- affect
		),
		affect : Gremlin!AffectationExpression(
			left <- unionContentVariableAccess,
			right <- vectorType
		),
		unionContentVariableAccess : Gremlin!VariableAccess(
			name <- 'unionContent'	
		),
		vectorType : Gremlin!VectorDefinition()
}

rule oclIsUndefined2steps {
	from
		select : OCL!OperationCallExp (select.getOpName() = 'oclIsUndefined')
	to
		toList : Gremlin!ToListCall(
			nextElement <- isEmpty	
		),
		isEmpty : Gremlin!IsEmptyCall(
			
		)
}

rule select2steps {
	from
		select : OCL!IteratorExp (select.getOpName() = 'select' and not select.isLastInCollectionOperation())
	to
		pp : Gremlin!FilterStep (
			closure <- cl,
			nextElement <- select.getComposite()
		),
		cl : Gremlin!Closure(
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(select.iterator.first())).append(select.body.getFirstInstruction())	
		)
}

lazy rule varIterator2def {
	from
		var :  OCL!Variable
	to
		vd : Gremlin!VariableDeclaration(
			name <- var.name,
			value <- fi
		),
		fi : Gremlin!ClosureIt()
}

rule selectLastInUnionRightPart2steps {
	from
		select : OCL!IteratorExp (select.getOpName() = 'select' and select.isLastInCollectionOperation() and not select.isInCollectionOperationLeftPart())
	to
		pp : Gremlin!FilterStep (
			closure <- cl,
			nextElement <- fill
		),
		cl : Gremlin!Closure(
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(select.iterator.first())).append(select.body.getFirstInstruction())	
		),
		fill : Gremlin!FillStep(
			instruction <- unionContentVariableAccess
		),
		unionContentVariableAccess : Gremlin!VariableAccess (
			name <- 'unionContent'
		)
}

rule selectLastInUnionLeftPart2steps {
	from
		select : OCL!IteratorExp (select.getOpName() = 'select' and select.isLastInCollectionOperation() and select.isInCollectionOperationLeftPart())
	to
		pp : Gremlin!FilterStep (
			closure <- cl,
			nextElement <- fill
		),
		cl : Gremlin!Closure(
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(select.iterator.first())).append(select.body.getFirstInstruction())	
		),
		fill : Gremlin!FillStep(
			instruction <- affect
		),
		affect : Gremlin!AffectationExpression(
			left <- unionContentVariableAccess,
			right <- vectorType
		),
		unionContentVariableAccess : Gremlin!VariableAccess(
			name <- 'unionContent'	
		),
		vectorType : Gremlin!VectorDefinition()
}

rule reject2steps {
	from
		reject : OCL!IteratorExp (reject.getOpName() = 'reject' and not reject.isLastInCollectionOperation())
	to
		pp : Gremlin!FilterStep (
			closure <-  clos,
			nextElement <- reject.getComposite()
		),
		clos : Gremlin!Closure (
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(reject.iterator.first())).append(notExp)
		),
		notExp : Gremlin!NotExpression (
			exp <- reject.body.getFirstInstruction()
		)
}

rule rejectLastInUnionRightPart2steps {
	from
		reject : OCL!IteratorExp (reject.getOpName() = 'reject' and reject.isLastInCollectionOperation() and not reject.isInCollectionOperationLeftPart())
	to
		pp : Gremlin!FilterStep (
			closure <- clos,
			nextElement <- fill
		),
		clos : Gremlin!Closure (
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(reject.iterator.first())).append(notExp)
		),
		notExp : Gremlin!NotExpression (
			exp <- reject.body.getFirstInstruction()
		),
		fill : Gremlin!FillStep(
			instruction <- unionContentVariableAccess
		),
		unionContentVariableAccess : Gremlin!VariableAccess(
			name <- 'unionContent'	
		)
}

rule rejectLastInUnionLeftPart2steps {
	from
		reject : OCL!IteratorExp (reject.getOpName() = 'reject' and reject.isLastInCollectionOperation() and reject.isInCollectionOperationLeftPart())
	to
		pp : Gremlin!FilterStep (
			closure <- clos,
			nextElement <- fill
		),
		clos : Gremlin!Closure(
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(reject.iterator.first())).append(notExp)
		),
		notExp : Gremlin!NotExpression (
			exp <- reject.body
		),
		fill : Gremlin!FillStep(
			instruction <- affect
		),
		affect : Gremlin!AffectationExpression(
			left <- unionContentVariableAccess,
			right <- vectorType
		),
		unionContentVariableAccess : Gremlin!VariableAccess(
			name <- 'unionContent'	
		),
		vectorType : Gremlin!VectorDefinition()
}

rule excludes2steps {
	from
		excludes : OCL!OperationCallExp (excludes.getOpName() = 'excludes')
	to
		retain : Gremlin!RetainStep(
			collection <- vec,
			nextElement <- toListCall	
		),
		toListCall : Gremlin!ToListCall(
			nextElement <- isEmptyCall	
		),
		isEmptyCall : Gremlin!IsEmptyCall(
		),
		vec : Gremlin!VectorType(
			values <- excludes.argument.first()	
		)
}

rule excludesAll2steps {
	from
		excludesAll : OCL!OperationCallExp (excludesAll.getOpName() = 'excludesAll')
	to
		retain : Gremlin!RetainStep(
			collection <- excludesAll.argument.first(),
			nextElement <- toListCall
		),
		toListCall : Gremlin!ToListCall(
			nextElement <- isEmptyCall	
		),
		isEmptyCall : Gremlin!IsEmptyCall(
		)
}

rule excluding2steps {
	from
		excluding : OCL!OperationCallExp (excluding.getOpName() = 'excluding')
	to
		exStep : Gremlin!ExceptStep (
			collection <- vec,
			nextElement <- excluding.getComposite()
		),
		vec : Gremlin!VectorDefinition (
			values <- excluding.argument.first()	
		)
}

rule includes2steps {
	from
		includes : OCL!OperationCallExp (includes.getOpName() = 'includes')
	to
		gather : Gremlin!GatherStep(
			nextElement <- transform	
		),
		transform : Gremlin!TransformStep(
			closure <- clos,
			nextElement <- nextCall
		),
		clos : Gremlin!Closure (
			instructions <- it
		),
		it : Gremlin!ClosureIt(
			nextElement <- containsCall	
		),
		containsCall : Gremlin!ContainsCall(
			value <- includes.argument.first()
		),
		nextCall : Gremlin!NextCall(
			nextElement <- includes.getComposite()	
		)
}

rule includesAll2steps {
	from
		includesAll : OCL!OperationCallExp (includesAll.getOpName() = 'includesAll')
	to
		gather : Gremlin!GatherStep(
			nextElement <- transform	
		),
		transform : Gremlin!TransformStep(
			closure <- clos,
			nextElement <- nextCall
		),
		clos : Gremlin!Closure (
			instructions <- it
		),
		it : Gremlin!ClosureIt(
			nextElement <- containsAllCall	
		),
		containsAllCall : Gremlin!ContainsAllCall(
			value <- includesAll.argument.first()
		),
		nextCall : Gremlin!NextCall(
			nextElement <- includesAll.getComposite()	
		)
}

rule including2steps {
	from
		including : OCL!OperationCallExp (including.getOpName() = 'including')
	to
		gather : Gremlin!GatherStep(
			nextElement <- transform	
		),
		transform : Gremlin!TransformStep(
			closure <- clos,
			nextElement <- scatter
		),
		clos : Gremlin!Closure (
			instructions <- shift
		),
		shift : Gremlin!LeftShiftExpression(
			left <- it,
			right <- including.argument.first()
		),
		it : Gremlin!ClosureIt(),
		scatter : Gremlin!ScatterStep(
			nextElement <- including.getComposite()	
		)
}

rule exists2steps {
	from
		exists : OCL!IteratorExp (exists.getOpName() = 'exists')
	to
		pp : Gremlin!FilterStep (
			closure <-  clos,
			nextElement <- hasNext
		),
		clos : Gremlin!Closure (
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(exists.iterator.first())).append(exists.body.getFirstInstruction())
		),
		hasNext : Gremlin!HasNextCall(
			
		)
}

rule forAll2steps {
	from
		forAll : OCL!IteratorExp (forAll.getOpName() = 'forAll')
	to
		pp : Gremlin!FilterStep(
			closure <- clos,
			nextElement <- toList
		),
		clos : Gremlin!Closure(
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(forAll.iterator.first())).append(notExp)
		),
		notExp : Gremlin!NotExpression(
			exp <- forAll.body.getFirstInstruction()	
		),
		toList : Gremlin!ToListCall(
			nextElement <- isEmptyCall	
		),
		isEmptyCall : Gremlin!IsEmptyCall(
			
		)
}

-- Create a TransformStep from an oclIsTypeOf() OperationCallExp
-- Step closure is also created with the node comparison corresponding to
-- type conformance
-- Using a closure to compare ease the transformation by avoiding preprocessing
-- to generate equality comparisons
rule oclIsTypeOf2steps {
	from
		oclIsTypeOf : OCL!OperationCallExp (
			oclIsTypeOf.getOpName() = 'oclIsTypeOf'	
		)
	to
		tran : Gremlin!TransformStep(
			closure <- cl,
			nextElement <- clNext
		),
		clNext : Gremlin!NextCall(
			nextElement <- oclIsTypeOf.getComposite()			
		),
		cl : Gremlin!Closure(
			instructions <- eq	
		),
		eq : Gremlin!EqualityExpression(
			left <- it,
			right <- oclIsTypeOf.argument.first()
		),
		it : Gremlin!ClosureIt(
			nextElement <- outE	
		),
		outE : Gremlin!OutEStep(
			relationshipName <- 'kyanosInstanceOf',
			nextElement <- inV
		),
		inV : Gremlin!InVStep(
			nextElement <- next	
		),
		next : Gremlin!NextCall()
}

rule oclAsType2steps {
	from
		oclAsType : OCL!OperationCallExp (
			oclAsType.getOpName() = 'oclAsType'	
		)
	to
		ip : Gremlin!IdentityStep(
			nextElement <- oclAsType.getComposite()
		)
}

rule size2steps {
	from
		size : OCL!OperationCallExp (
			size.getOpName() = 'size'
		)
	to
		cc : Gremlin!CountCall (	
		)
}

rule isEmpty2steps {
	from
		isEmpty : OCL!OperationCallExp (
			isEmpty.getOpName() = 'isEmpty'	
		)
	to
		toList : Gremlin!ToListCall(
			nextElement <- isEmptyCall
		),
		isEmptyCall : Gremlin!IsEmptyCall(
			nextElement <- isEmpty.getComposite()
		)
}

-- Transfroms a variable access expression into Gremlin filter iterator Step.
-- TODO : handle non-iterator variables
rule varExp2steps {
	from
		varExp : OCL!VariableExp(
			not(varExp.isInCollect())	
		)
	to
		va : Gremlin!VariableAccess(
			name <- varExp.referredVariable.name,
			nextElement <- varExp.getComposite()
		)
}

rule varExpInCollect2steps {
	from
		varExp : OCL!VariableExp (
			varExp.isInCollect()	
		)
	to
		id : Gremlin!IdentityStep(
			nextElement <- varExp.getComposite()	
		)
}

rule propertyRefCallExp2steps {
	from
		prop : OCL!PropertyCallExp(
			prop.referredProperty.oclIsKindOf(OCL!EReference) and
			not(prop.isLastInComparison())
		)
	to
		outE : Gremlin!OutEStep(
			relationshipName <- prop.referredProperty.name,
			nextElement <- inV
		),
		inV : Gremlin!InVStep(
			nextElement <- prop.getComposite()
		)
}

rule propertyRefLastInComparison2steps {
	from
		prop : OCL!PropertyCallExp(
			prop.referredProperty.oclIsKindOf(OCL!EReference) and
			(prop.isLastInComparison())
		)
	to
		outE : Gremlin!OutEStep(
			relationshipName <- prop.referredProperty.name,
			nextElement <- inV
		),
		inV : Gremlin!InVStep(
			nextElement <- nCall
		),
		nCall : Gremlin!NextCall(
			nextElement <- prop.getComposite()	
		)
}

rule propertyAttCallExp2steps {
	from
		prop : OCL!PropertyCallExp(
			prop.referredProperty.oclIsKindOf(OCL!EAttribute)-- and
	--		not(prop.isLastInComparison())
		)
	to
		pp : Gremlin!PropertyStep(
			name <- prop.referredProperty.name,
			nextElement <- prop.getComposite()
		)
}

rule propertyAttBooleanLastInComparison2steps {
	from
		prop : OCL!PropertyCallExp(
			prop.referredProperty.oclIsTypeOf(OCL!EAttribute) and
			prop.referredProperty.eType.oclIsTypeOf(OCL!EDataType) and
			prop.referredProperty.eType.name = 'EBoolean'and
			prop.isLastInComparison()
		)
	to
		pp : Gremlin!PropertyStep(
			name <- prop.referredProperty.name,
			nextElement <- transform
		),
		transform : Gremlin!TransformStep(
			closure <- clos,
			nextElement <- nextCall
		),
		clos : Gremlin!Closure(
			instructions <- eq
		),
		eq : Gremlin!EqualityExpression(
			left <- closureIt,
			right <- bool
		),
		closureIt : Gremlin!ClosureIt(
			
		),
		bool : Gremlin!StringLiteral(
			value <- 'true'
		),
		nextCall : Gremlin!NextCall(
			nextElement <- prop.getComposite()	
		)
}

rule oclFirst2steps {
	from
		oclFirst : OCL!OperationCallExp(oclFirst.getOpName() = 'first')
	to
		fc : Gremlin!FirstCall(
			nextElement <- oclFirst.getComposite()
		)
}
