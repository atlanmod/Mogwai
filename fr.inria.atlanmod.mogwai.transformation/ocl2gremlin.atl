-- @path OCL=http://www.eclipse.org/ocl/1.1.0/Ecore
-- @path Gremlin=/fr.inria.atlanmod.mogwai.gremlin/model/gremlin.ecore

-- OCL to Gremlin ATL Module

-- Transforms an OCL input model into its representation through the
-- Gremlin metamodel (see fr.inria.atlanmod.ocl2query.gremlin).
-- OCL models are reversed compare to the natural writing :
--		a->collect(b)->select(e | e.oclIsTypeOf(X))
--	produces a model like
--		select(collect(access(a)))
-- While Gremlin syntax and model are both organized in the natural writing 
-- order. The main objective of this transformation is to reverse OCL expression
-- chains to match them in prefixed order.
-- The typical matching is done in 2 parts :
--	- Find the highest object in the considered tree hierarchy
--  - Match this object to a step and associate next step to the container of the object

-- Author AtlanMod - Inria

module ocl2gremlin;

create OUT: Gremlin from IN: OCL;

-- Get the name of a call expression
-- Supported expression are OperationCall and Iterator
helper context OCL!CallExp def : getOpName() : String = 
	if self.oclIsTypeOf(OCL!OperationCallExp) then
		self.referredOperation.name
	else
		if self.oclIsTypeOf(OCL!IteratorExp) then
			self.name
		else
			OclUndefined
		endif
	endif
	;

-- Returns all the expressions in the OCLExpression tree that
-- are allInstances() operations
helper context OCL!OCLExpression def : getTypeExps() : OrderedSet(OCL!TypeExp) =
	OCL!TypeExp.allInstances()->iterate(each; res : OrderedSet(OCL!TypeExp) = OrderedSet{} | 
		if(res->collect(e | e.referredType.name)->includes(each.referredType.name)) then
			res
		else
			res.append(each)
		endif)
	;
	
helper context OclAny def : getComposite() : OclAny =
	let composite : OclAny = self.refImmediateComposite() in
	if composite.oclIsTypeOf(OCL!ExpressionInOCL) then
		-- ExpressionInOCL is the root element of the query (the "specification" reference
		-- of the constraint). Returns OclUndefined to flag the end of the traversal
		OclUndefined
	else
		-- Collect flattening
		if composite.oclIsTypeOf(OCL!IteratorExp) then
			if composite.getOpName() = 'collect' then
				if composite.hasInBody(self) then
					-- If self is the last element in the collect expression returns
					-- the collect operation to handle unions
					composite
				else
					-- If self is not in the collect expression returns the content
					-- of the expression (it flatten collect and delegate its translation
					-- at the end of its inner expression)
					composite.body.getFirstInstruction()
				endif
			else 
				if composite.getOpName() = 'select' then
					if composite.hasInBody(self) then
						OclUndefined
					else
						composite
					endif
				else
					if composite.getOpName() = 'reject' then
						if composite.hasInBody(self) then
							OclUndefined
						else
							-- If the next operation is not a collect returns it
							composite
						endif
					else
						if composite.getOpName() = 'exists' then
							if composite.hasInBody(self) then
								OclUndefined
							else
								composite
							endif
						else
							if composite.getOpName() = 'forAll' then
								if composite.hasInBody(self) then
									OclUndefined
								else
									composite
								endif
							else
								composite
							endif
						endif
					endif
				endif
			endif
		else
			if composite.oclIsTypeOf(OCL!OperationCallExp) then
				if composite.isComparison() then
					-- If the container is a comparison there is two solutions:
					-- (i)  It contains self, and has been handled before
					-- (ii) It doesn't, and it is an error (it should have been handeled before)
					OclUndefined
				else
					if composite.getOpName() = 'oclIsTypeOf' then
						if composite.hasInBody(self) then
							OclUndefined
						else
							composite
						endif
					else
						if composite.getOpName() = 'union' then
							OclUndefined
						else
					-- The container is a function call
						if composite.hasInArguments(self) then
						-- The container contains self in its arguments, it has been handled
						-- before
							OclUndefined
						else
						-- The container does not contain self in its argument, simply handle it
							composite
						endif
						endif
					endif
				endif
			else
				-- If the next element is not an iterator or an operation returns it
				composite
			endif
		endif
	endif
	;

helper context OCL!OperationCallExp def : hasInArguments(o : OclAny) : Boolean =
	if self.argument->size() = 0 then
		false
	else
		self.recursiveHasInArguments(o, self.argument.first().getFirstInstruction())
	endif
	;

helper context OCL!OperationCallExp def : recursiveHasInArguments(o : OclAny, e : OCL!OCLExpression) : Boolean =
	if e = self then
		false
	else
		if e = o then
			true
		else
			self.recursiveHasInArguments(o, e.refImmediateComposite())
		endif
	endif
	;

helper context OCL!IteratorExp def : hasInBody(o : OclAny) : Boolean = 
	self.recursiveHasInBody(o,self.body.getFirstInstruction())
	;

helper context OCL!OperationCallExp def : hasInBody(o : OclAny): Boolean =
	self.recursiveHasInBody(o,self.argument.first().getFirstInstruction())
	;

helper context OCL!IteratorExp def : recursiveHasInBody(o : OclAny, e : OCL!OCLExpression) : Boolean =
	if e = self then
		false
	else
		if e = o then
			true
		else
			self.recursiveHasInBody(o, e.refImmediateComposite())
		endif
	endif
	;

helper context OCL!OperationCallExp def : recursiveHasInBody(o : OclAny, e : OCL!OCLExpression) : Boolean =
	if e = self then
		false
	else
		if e = o then
			true
		else
			self.recursiveHasInBody(o, e.refImmediateComposite())
		endif
	endif
	;
	
helper context OCL!OCLExpression def : isInCollect() : Boolean = 
	if self.refImmediateComposite().oclIsTypeOf(OCL!IteratorExp) then
		self.refImmediateComposite().name = 'collect'
	else
		self.refImmediateComposite().isInCollect()
	endif
	;

helper context OCL!OCLExpression def : getFirstInstruction() : OCL!OCLExpression =
	if self.oclIsTypeOf(OCL!OperationCallExp) then
		if self.isComparison() then
			self
		else
			self.source.getFirstInstruction()
		endif
	else
		if self.oclIsTypeOf(OCL!IteratorExp) then
			self.source.getFirstInstruction()
		else
			if self.oclIsTypeOf(OCL!VariableExp) or
				self.oclIsKindOf(OCL!LiteralExp) or
				self.oclIsTypeOf(OCL!TypeExp) or
				self.oclIsKindOf(OCL!BooleanLiteralExp) then
				self
			else
				self.source.getFirstInstruction()
			endif
		endif
	endif
	;

helper context OCL!OCLExpression def : getFirstInstructionUnion() : OCL!OCLExpression =
	if self.oclIsTypeOf(OCL!OperationCallExp) or self.oclIsTypeOf(OCL!IteratorExp) then
		if self.getOpName() = 'union' then
			self
		else
			self.source.getFirstInstructionUnion()
		endif
	else
		if self.oclIsTypeOf(OCL!VariableExp) or
			self.oclIsKindOf(OCL!LiteralExp) or
			self.oclIsTypeOf(OCL!TypeExp) or
			self.oclIsKindOf(OCL!BooleanLiteralExp) then
			self
		else
			self.source.getFirstInstructionUnion()
		endif
	endif
	;

helper context OCL!OCLExpression def : getFirstInstructionInUnions() : OrderedSet(OCL!OCLExpression) =
	if OCL!OperationCallExp.allInstances()->select(each | each.getOpName() = 'union').size() = 0 then
--		self.getFirstInstruction() removed to avoid cast error if there is no union
		OrderedSet{}
	else
		thisModule.reverse(OCL!OperationCallExp.allInstances())->select(each | each.getOpName() = 'union')->collect(e | OrderedSet{}.append(e.argument.first().getFirstInstructionUnion())).flatten()
	endif
	;

helper def : reverse(seq : Sequence(OclAny)): Sequence(OclAny) = seq->iterate(e; res : Sequence(OclAny) = Sequence{} | res.prepend(e));

helper context OCL!OCLExpression def : isLastInUnion() : Boolean =
	if self.refImmediateComposite().oclIsTypeOf(OCL!OperationCallExp) then
		if self.refImmediateComposite().getOpName() = 'union' then
			true
		else
			false
		endif
	else
		false
	endif
	;

helper context OCL!OCLExpression def : isInUnionLeftPart() : Boolean =
	if self.isLastInUnion() then
		self.refImmediateComposite().source = self
	else
		false
	endif
	;

helper context OCL!OCLExpression def : getUnionVariableName() : String =
	let res : String = 'union' in
		if self.isInUnionLeftPart() then
			res + 'Left' + thisModule.getUnionIndex(self.refImmediateComposite())
		else
			res + 'Right' + thisModule.getUnionIndex(self.refImmediateComposite())
		endif
	;

-- Returns the first element in an OCL operation chain. Allow the transformation of
-- the chain in Gremlin order.
-- TODO : Check if all the termination conditions have been met.
helper context OCL!OCLExpression def : getFirstOperation() : OCL!OCLExpression = 
	if self.oclIsTypeOf(OCL!OperationCallExp) then
		if self.getOpName() = 'size' then
			self.source.getFirstOperation()
		else if self.getOpName() = 'oclAsType' then
			self.source.getFirstOperation()
		else if self.getOpName() = 'oclIsUndefined' then
			self.source.getFirstOperation()
		else
			self
		endif
		endif
		endif
	else
		if self.oclIsTypeOf(OCL!VariableExp) or
			self.oclIsKindOf(OCL!LiteralExp) or
			self.oclIsKindOf(OCL!BooleanLiteralExp) then
			self
		else
			self.source.getFirstOperation()
		endif
	endif
	;

helper context OCL!PropertyCallExp def : isLastInComparison() : Boolean =
	if self.refImmediateComposite().oclIsTypeOf(OCL!OperationCallExp) then
		self.refImmediateComposite().isComparison()
	else
		false
	endif
	;

helper context OCL!OperationCallExp def : isComparison() : Boolean =
	OrderedSet{'=','or','and','>','>=','<','<=','<>','not'}.includes(self.getOpName())
	;
	
-- Creates the Gremlin container (GremlinScript) from
-- the OCL container (Constraint)
-- Meta elements are computed first to generate appropriate variables (for type checking
-- and indices access).
-- The first instruction (i.e the last one in the OCL model) is then retrieved and added to the
-- instruction list.
rule constraint2script {
	from
		cc : OCL!Constraint
	to
		gg : Gremlin!GremlinScript (
			instructions <- cc.specification.bodyExpression.getTypeExps()
				->collect(e | thisModule.typeExp2meta(e)).union(
					cc.specification.bodyExpression.getTypeExps()
				->collect(e | thisModule.typeExp2metaNodes(e))).union(
					let unions : Sequence(OCL!OperationCallExp) = OCL!OperationCallExp.allInstances()->select(each | each.getOpName() = 'union') in
					if unions.isEmpty() then
						OrderedSet{}
					else
						unions->collect(e | thisModule.union2metaLeft(e)).union(
							unions->collect(e | thisModule.union2metaRight(e))	
						).append(thisModule.unionMetaMethod(unions.first()))
					endif).
				append(
					cc.specification.bodyExpression.getFirstInstruction()
				).
				union(
					cc.specification.bodyExpression.getFirstInstructionInUnions()
				).
				union(
					OCL!OperationCallExp.allInstances()->select(each | each.getOpName() = 'union')	
				)
		)
}

-- Creates variables associated to allInstances calls to avoid multiple index
-- accesses in the same step.
-- @see allInstances2steps for generated steps.
lazy rule typeExp2meta {
	from
		typeExp : OCL!TypeExp
	to
		metaVar : Gremlin!VariableDeclaration (
			name <- 'meta'+typeExp.referredType.name,
			value <- metaStartStep
		),
		metaStartStep : Gremlin!StartStep (
			nextElement <- idxCall	
		),
		idxCall : Gremlin!IndexCall (
			indexName <- 'metaclasses',
			indexProperty  <- 'name',
			indexQuery <- typeExp.referredType.name
		)
}

-- Creates variables associated to oclIsTypeOf calls to avoid multiple index
-- accesses in the same step.
-- @see oclIsTypeOf2steps for generated steps.
lazy rule typeExp2metaNodes {
	from
		typeExp : OCL!TypeExp
	to
		metaVar : Gremlin!VariableDeclaration(
			name <- 'meta'+typeExp.referredType.name+'Node',
			value <- metaVarAccess
		),
		metaVarAccess : Gremlin!VariableAccess(
			name <- 'meta'+typeExp.referredType.name,
			nextElement <- nextIt
		),
		nextIt : Gremlin!NextCall ()
		
}

helper def : getUnionIndex(u : OCL!OperationCallExp) : Integer =
	OCL!OperationCallExp.allInstances()->select(each | each.getOpName() = 'union')->indexOf(u)
	;

lazy rule unionMetaMethod {
	from
		oclUnion : OCL!OperationCallExp
	to
		md : Gremlin!MethodDeclaration(
			name <- 'computeUnion',
			parameters <- Sequence{'c1','c2'},
			instructions <- Sequence{i1,i2}
		),
		i1 : Gremlin!VariableAccess(
			name <- 'c1',
			nextElement <- addAllCall
		),
		addAllCall : Gremlin!AddAllCall(
			value <- vc2	
		),
		vc2 : Gremlin!VariableAccess(
			name <- 'c2'	
		),
		i2 : Gremlin!VariableAccess(
			name <- 'c1'	
		)
}

-- Create variables to store union parts
lazy rule union2metaLeft {
	from
		oclUnion : OCL!OperationCallExp
	to
		metaUnionVar : Gremlin!VariableDeclaration (
			name <- 'unionLeft' + thisModule.getUnionIndex(oclUnion),
			value <- col
		),
		col : Gremlin!CollectionDefinition ()
}

lazy rule union2metaRight {
	from
		oclUnion : OCL!OperationCallExp
	to
		metaUnionVar : Gremlin!VariableDeclaration(
			name <- 'unionRight' + thisModule.getUnionIndex(oclUnion),
			value <- col
		),
		col : Gremlin!CollectionDefinition()
}

rule union2steps {
	from
		union : OCL!OperationCallExp (union.getOpName() = 'union')
	to
		uc : Gremlin!UnionCall(
			leftCollection <- vaL,
			rightCollection <- vaR,
			cast <- thisModule.lazyCol(union.eType),
			nextElement <- idStep
		),
		vaL : Gremlin!VariableAccess(
			name <- union.source.getUnionVariableName()	
		),
		vaR : Gremlin!VariableAccess(
			name <- union.argument.first().getUnionVariableName()	
		),
		idStep : Gremlin!IdentityStep(
			nextElement <- union.getComposite()	
		)
}

lazy rule lazyCol {
	from
		colType : OCL!CollectionType
	to
		decl : Gremlin!TypeDeclaration()
}

lazy rule lazySeq extends lazyCol {
	from
		colType : OCL!SequenceType
	to
		decl : Gremlin!ListDeclaration
}

lazy rule lazySet extends lazyCol {
	from
		colType : OCL!SetType
	to
		decl : Gremlin!SetDeclaration
}

lazy rule lazyOrderedSet extends lazyCol {
	from
		colType : OCL!OrderedSetType
	to
		decl : Gremlin!SortedSetDeclaration
}

lazy rule lazyBag extends lazyCol {
	from
		colType : OCL!BagType
	to
		decl : Gremlin!ListDeclaration
}
--rule union2steps {
--	from
--		oclUnion : OCL!OperationCallExp (oclUnion.getOpName() = 'union')
--	to
--		gg : Gremlin!VariableAccess(
--			name <- 'unionContent',
--			nextElement <- idStep
--		),
--		idStep : Gremlin!IdentityStep(
--			nextElement <- if oclUnion.getComposite().getOpName() = 'union' then
--							OclUndefined
--							else
--								oclUnion.getComposite()
--							endif
--		)
--}

-- Transforms 'allInstances' expressions into kyanosInstanceOf edge step
-- and vertex step.
--lazy rule allInstances2steps {
rule allInstances2steps {
	from
		allInstances : OCL!OperationCallExp (allInstances.getOpName() = 'allInstances')
	to
		ine : Gremlin!InEStep (
			relationshipName <- 'kyanosInstanceOf',
			nextElement <- outv
		),
		outv : Gremlin!OutVStep (
			nextElement <- allInstances.getComposite()
		)
}

rule typeExp2steps {
	from
		typeExp : OCL!TypeExp (
			if typeExp.refImmediateComposite().oclIsTypeOf(OCL!OperationCallExp) then
				not(typeExp.refImmediateComposite().getOpName() = 'oclAsType')
			else
				true
			endif
		)
	to
		vap : Gremlin!VariableAccess(
			name <- 'meta'+	typeExp.referredType.name+'Node',
			nextElement <- typeExp.getComposite()
		)
}

-- Transforms 'collect' expressions into edge and vertex step.
rule collect2steps {
	from 
		collect : OCL!IteratorExp (collect.getOpName() = 'collect' and not collect.isLastInUnion())
	to
		id : Gremlin!IdentityStep(
			nextElement <- collect.getComposite()
		)
}

rule collectLastInUnionRightPart2steps {
	from 
		collect : OCL!IteratorExp (collect.getOpName() = 'collect' and collect.isLastInUnion() and not collect.isInUnionLeftPart())
	to
		fill : Gremlin!FillStep(
			instruction <- unionContentVariableAccess
		),
		unionContentVariableAccess : Gremlin!VariableAccess (
			name <- 'unionContent'
		)
}

rule collectLastInUnionLeftPart2steps {
	from 
		collect : OCL!IteratorExp (collect.getOpName() = 'collect' and collect.isLastInUnion() and collect.isInUnionLeftPart())
	to
		fill : Gremlin!FillStep(
			instruction <- affect
		),
		affect : Gremlin!AffectationExpression(
			left <- unionContentVariableAccess,
			right <- vectorType
		),
		unionContentVariableAccess : Gremlin!VariableAccess(
			name <- 'unionContent'	
		),
		vectorType : Gremlin!VectorDefinition()
}

rule oclIsUndefined2steps {
	from
		select : OCL!OperationCallExp (select.getOpName() = 'oclIsUndefined')
	to
		toList : Gremlin!ToListCall(
			nextElement <- isEmpty	
		),
		isEmpty : Gremlin!IsEmptyCall(
			
		)
}

rule select2steps {
	from
		select : OCL!IteratorExp (select.getOpName() = 'select' and not select.isLastInUnion())
	to
		pp : Gremlin!FilterStep (
			closure <- cl,
			nextElement <- select.getComposite()
		),
		cl : Gremlin!Closure(
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(select.iterator.first())).append(select.body.getFirstInstruction())	
		)
}

lazy rule varIterator2def {
	from
		var :  OCL!Variable
	to
		vd : Gremlin!VariableDeclaration(
			name <- var.name,
			value <- fi
		),
		fi : Gremlin!ClosureIt()
}

rule selectLastInUnionRightPart2steps {
	from
		select : OCL!IteratorExp (select.getOpName() = 'select' and select.isLastInUnion() and not select.isInUnionLeftPart())
	to
		pp : Gremlin!FilterStep (
			closure <- cl,
			nextElement <- fill
		),
		cl : Gremlin!Closure(
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(select.iterator.first())).append(select.body.getFirstInstruction())	
		),
		fill : Gremlin!FillStep(
			instruction <- unionContentVariableAccess
		),
		unionContentVariableAccess : Gremlin!VariableAccess (
			name <- 'unionContent'
		)
}

rule selectLastInUnionLeftPart2steps {
	from
		select : OCL!IteratorExp (select.getOpName() = 'select' and select.isLastInUnion() and select.isInUnionLeftPart())
	to
		pp : Gremlin!FilterStep (
			closure <- cl,
			nextElement <- fill
		),
		cl : Gremlin!Closure(
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(select.iterator.first())).append(select.body.getFirstInstruction())	
		),
		fill : Gremlin!FillStep(
			instruction <- affect
		),
		affect : Gremlin!AffectationExpression(
			left <- unionContentVariableAccess,
			right <- vectorType
		),
		unionContentVariableAccess : Gremlin!VariableAccess(
			name <- 'unionContent'	
		),
		vectorType : Gremlin!VectorDefinition()
}

rule reject2steps {
	from
		reject : OCL!IteratorExp (reject.getOpName() = 'reject' and not reject.isLastInUnion())
	to
		pp : Gremlin!FilterStep (
			closure <-  clos,
			nextElement <- reject.getComposite()
		),
		clos : Gremlin!Closure (
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(reject.iterator.first())).append(notExp)
		),
		notExp : Gremlin!NotExpression (
			exp <- reject.body.getFirstInstruction()
		)
}

rule rejectLastInUnionRightPart2steps {
	from
		reject : OCL!IteratorExp (reject.getOpName() = 'reject' and reject.isLastInUnion() and not reject.isInUnionLeftPart())
	to
		pp : Gremlin!FilterStep (
			closure <- clos,
			nextElement <- fill
		),
		clos : Gremlin!Closure (
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(reject.iterator.first())).append(notExp)
		),
		notExp : Gremlin!NotExpression (
			exp <- reject.body.getFirstInstruction()
		),
		fill : Gremlin!FillStep(
			instruction <- unionContentVariableAccess
		),
		unionContentVariableAccess : Gremlin!VariableAccess(
			name <- 'unionContent'	
		)
}

rule rejectLastInUnionLeftPart2steps {
	from
		reject : OCL!IteratorExp (reject.getOpName() = 'reject' and reject.isLastInUnion() and reject.isInUnionLeftPart())
	to
		pp : Gremlin!FilterStep (
			closure <- clos,
			nextElement <- fill
		),
		clos : Gremlin!Closure(
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(reject.iterator.first())).append(notExp)
		),
		notExp : Gremlin!NotExpression (
			exp <- reject.body
		),
		fill : Gremlin!FillStep(
			instruction <- affect
		),
		affect : Gremlin!AffectationExpression(
			left <- unionContentVariableAccess,
			right <- vectorType
		),
		unionContentVariableAccess : Gremlin!VariableAccess(
			name <- 'unionContent'	
		),
		vectorType : Gremlin!VectorDefinition()
}

rule excludes2steps {
	from
		excludes : OCL!OperationCallExp (excludes.getOpName() = 'excludes')
	to
		retain : Gremlin!RetainStep(
			collection <- vec,
			nextElement <- toListCall	
		),
		toListCall : Gremlin!ToListCall(
			nextElement <- isEmptyCall	
		),
		isEmptyCall : Gremlin!IsEmptyCall(
		),
		vec : Gremlin!VectorType(
			values <- excludes.argument.first()	
		)
}

rule excludesAll2steps {
	from
		excludesAll : OCL!OperationCallExp (excludesAll.getOpName() = 'excludesAll')
	to
		retain : Gremlin!RetainStep(
			collection <- excludesAll.argument.first(),
			nextElement <- toListCall
		),
		toListCall : Gremlin!ToListCall(
			nextElement <- isEmptyCall	
		),
		isEmptyCall : Gremlin!IsEmptyCall(
		)
}

rule excluding2steps {
	from
		excluding : OCL!OperationCallExp (excluding.getOpName() = 'excluding')
	to
		exStep : Gremlin!ExceptStep (
			collection <- vec,
			nextElement <- excluding.getComposite()
		),
		vec : Gremlin!VectorDefinition (
			values <- excluding.argument.first()	
		)
}

rule includes2steps {
	from
		includes : OCL!OperationCallExp (includes.getOpName() = 'includes')
	to
		gather : Gremlin!GatherStep(
			nextElement <- transform	
		),
		transform : Gremlin!TransformStep(
			closure <- clos,
			nextElement <- nextCall
		),
		clos : Gremlin!Closure (
			instructions <- it
		),
		it : Gremlin!ClosureIt(
			nextElement <- containsCall	
		),
		containsCall : Gremlin!ContainsCall(
			value <- includes.argument.first()
		),
		nextCall : Gremlin!NextCall(
			nextElement <- includes.getComposite()	
		)
}

rule includesAll2steps {
	from
		includesAll : OCL!OperationCallExp (includesAll.getOpName() = 'includesAll')
	to
		gather : Gremlin!GatherStep(
			nextElement <- transform	
		),
		transform : Gremlin!TransformStep(
			closure <- clos,
			nextElement <- nextCall
		),
		clos : Gremlin!Closure (
			instructions <- it
		),
		it : Gremlin!ClosureIt(
			nextElement <- containsAllCall	
		),
		containsAllCall : Gremlin!ContainsAllCall(
			value <- includesAll.argument.first()
		),
		nextCall : Gremlin!NextCall(
			nextElement <- includesAll.getComposite()	
		)
}

rule including2steps {
	from
		including : OCL!OperationCallExp (including.getOpName() = 'including')
	to
		gather : Gremlin!GatherStep(
			nextElement <- transform	
		),
		transform : Gremlin!TransformStep(
			closure <- clos,
			nextElement <- scatter
		),
		clos : Gremlin!Closure (
			instructions <- shift
		),
		shift : Gremlin!LeftShiftExpression(
			left <- it,
			right <- including.argument.first()
		),
		it : Gremlin!ClosureIt(),
		scatter : Gremlin!ScatterStep(
			nextElement <- including.getComposite()	
		)
}

rule exists2steps {
	from
		exists : OCL!IteratorExp (exists.getOpName() = 'exists')
	to
		pp : Gremlin!FilterStep (
			closure <-  clos,
			nextElement <- hasNext
		),
		clos : Gremlin!Closure (
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(exists.iterator.first())).append(exists.body.getFirstInstruction())
		),
		hasNext : Gremlin!HasNextCall(
			
		)
}

rule forAll2steps {
	from
		forAll : OCL!IteratorExp (forAll.getOpName() = 'forAll')
	to
		pp : Gremlin!FilterStep(
			closure <- clos,
			nextElement <- toList
		),
		clos : Gremlin!Closure(
			instructions <- OrderedSet{}.append(thisModule.varIterator2def(forAll.iterator.first())).append(notExp)
		),
		notExp : Gremlin!NotExpression(
			exp <- forAll.body.getFirstInstruction()	
		),
		toList : Gremlin!ToListCall(
			nextElement <- isEmptyCall	
		),
		isEmptyCall : Gremlin!IsEmptyCall(
			
		)
}

-- Create a TransformStep from an oclIsTypeOf() OperationCallExp
-- Step closure is also created with the node comparison corresponding to
-- type conformance
-- Using a closure to compare ease the transformation by avoiding preprocessing
-- to generate equality comparisons
rule oclIsTypeOf2steps {
	from
		oclIsTypeOf : OCL!OperationCallExp (
			oclIsTypeOf.getOpName() = 'oclIsTypeOf'	
		)
	to
		tran : Gremlin!TransformStep(
			closure <- cl,
			nextElement <- clNext
		),
		clNext : Gremlin!NextCall(
			nextElement <- oclIsTypeOf.getComposite()			
		),
		cl : Gremlin!Closure(
			instructions <- eq	
		),
		eq : Gremlin!EqualityExpression(
			left <- it,
			right <- oclIsTypeOf.argument.first()
		),
		it : Gremlin!ClosureIt(
			nextElement <- outE	
		),
		outE : Gremlin!OutEStep(
			relationshipName <- 'kyanosInstanceOf',
			nextElement <- inV
		),
		inV : Gremlin!InVStep(
			nextElement <- next	
		),
		next : Gremlin!NextCall()
}

rule oclAsType2steps {
	from
		oclAsType : OCL!OperationCallExp (
			oclAsType.getOpName() = 'oclAsType'	
		)
	to
		ip : Gremlin!IdentityStep(
			nextElement <- oclAsType.getComposite()
		)
}

rule size2steps {
	from
		size : OCL!OperationCallExp (
			size.getOpName() = 'size'
		)
	to
		cc : Gremlin!CountCall (	
		)
}

rule isEmpty2steps {
	from
		isEmpty : OCL!OperationCallExp (
			isEmpty.getOpName() = 'isEmpty'	
		)
	to
		toList : Gremlin!ToListCall(
			nextElement <- isEmptyCall
		),
		isEmptyCall : Gremlin!IsEmptyCall(
			nextElement <- isEmpty.getComposite()
		)
}

-- Transforms '=' expression into Gremlin EqualityExpression.
-- First left and right operations are computed to get the correct sub-Step start.
-- @see equality2steps for equality generation with empty references checking.
rule equality2steps2 {
	from
		eq : OCL!OperationCallExp(eq.getOpName() = '=')
	to
		eqExp : Gremlin!EqualityExpression(
			left <- eq.source.getFirstOperation(),
			right <- eq.argument.first().getFirstOperation()
		)
}

rule not2steps {
	from
		notExp : OCL!OperationCallExp(
			notExp.getOpName() = 'not'	
		)
	to
		gremlinNot : Gremlin!NotExpression(
			exp <- notExp.source.getFirstInstruction()
		)
}

-- Transforms 'or' expression into Gremlin OrExpression.
-- First left and right operations are computed to get the correct sub-Step start.
rule or2steps {
	from
		orExp : OCL!OperationCallExp(
			orExp.getOpName() = 'or'
			)
	to
		gremlinOr : Gremlin!OrExpression(
			left <- orExp.source.getFirstOperation(),
			right <- orExp.argument.first().getFirstOperation()
		)
}

-- Transforms 'and' expression into Gremlin AndExpression.
-- First left and right operations are computed to get the correct sub-Step start.
rule and2steps {
	from
		andExp : OCL!OperationCallExp (
			andExp.getOpName() = 'and'	
		)
	to
		gremlinAnd : Gremlin!AndExpression(
			left <- andExp.source.getFirstInstruction(),
			right <- andExp.argument.first().getFirstInstruction()
		)
}

-- Transforms '>' expression into Gremlin GreaterExpression.
-- First left and right operations are computed to get the correct sub-Step start.
rule greater2steps {
	from
		greaterExp : OCL!OperationCallExp (
			greaterExp.getOpName() = '>'	
		)
	to
		gremlinGreater : Gremlin!GreaterExpression (
			left <- greaterExp.source.getFirstOperation(),
			right <- greaterExp.argument.first().getFirstOperation()
		)
}

-- Transforms '>=' expression into Gremlin GreaterOrEqualExpression.
-- First left and right operations are computed to get the correct sub-Step start.
rule greaterOrEqual2steps {
	from
		greaterOrEqualExp : OCL!OperationCallExp (
			greaterOrEqualExp.getOpName() = '>='	
		)
	to
		gremlinGreaterOrEqual : Gremlin!GreaterOrEqualExpression (
			left <- greaterOrEqualExp.source.getFirstOperation(),
			right <- greaterOrEqualExp.argument.first().getFirstOperation()
		)
}

-- Transforms '<' expression into Gremlin LessExpression.
-- First left and right operations are computed to get the correct sub-Step start.
rule less2steps {
	from
		lessExp : OCL!OperationCallExp (
			lessExp.getOpName() = '<'	
		)
	to
		gremlinLess : Gremlin!LessExpression (
			left <- lessExp.source.getFirstOperation(),
			right <- lessExp.argument.first().getFirstOperation()
		)
}

-- Transforms '<=' expression into Gremlin LessOrEqualExpression.
-- First left and right operations are computed to get the correct sub-Step start.
rule lessOrEqual2steps {
	from
		lessOrEqualExp : OCL!OperationCallExp (
			lessOrEqualExp.getOpName() = '<='
		)
	to
		gremlinLessOrEqual : Gremlin!LessOrEqualExpression (
			left <- lessOrEqualExp.source.getFirstOperation(),
			right <- lessOrEqualExp.argument.first().getFirstOperation()
		)
}

rule different2steps {
	from
		differentExp : OCL!OperationCallExp (
			differentExp.getOpName() = '<>'
		)
	to
		gremlinDifferent : Gremlin!DifferenceExpression (
			left <- differentExp.source.getFirstOperation(),
			right <- differentExp.argument.first().getFirstOperation()
		)
}

-- Transfroms a variable access expression into Gremlin filter iterator Step.
-- TODO : handle non-iterator variables
rule varExp2steps {
	from
		varExp : OCL!VariableExp(
			not(varExp.isInCollect())	
		)
	to
		va : Gremlin!VariableAccess(
			name <- varExp.referredVariable.name,
			nextElement <- varExp.getComposite()
		)
}

rule varExpInCollect2steps {
	from
		varExp : OCL!VariableExp (
			varExp.isInCollect()	
		)
	to
		id : Gremlin!IdentityStep(
			nextElement <- varExp.getComposite()	
		)
}

rule propertyRefCallExp2steps {
	from
		prop : OCL!PropertyCallExp(
			prop.referredProperty.oclIsKindOf(OCL!EReference) and
			not(prop.isLastInComparison())
		)
	to
		outE : Gremlin!OutEStep(
			relationshipName <- prop.referredProperty.name,
			nextElement <- inV
		),
		inV : Gremlin!InVStep(
			nextElement <- prop.getComposite()
		)
}

rule propertyRefLastInComparison2steps {
	from
		prop : OCL!PropertyCallExp(
			prop.referredProperty.oclIsKindOf(OCL!EReference) and
			(prop.isLastInComparison())
		)
	to
		outE : Gremlin!OutEStep(
			relationshipName <- prop.referredProperty.name,
			nextElement <- inV
		),
		inV : Gremlin!InVStep(
			nextElement <- nCall
		),
		nCall : Gremlin!NextCall(
			nextElement <- prop.getComposite()	
		)
}

rule propertyAttCallExp2steps {
	from
		prop : OCL!PropertyCallExp(
			prop.referredProperty.oclIsKindOf(OCL!EAttribute)-- and
	--		not(prop.isLastInComparison())
		)
	to
		pp : Gremlin!PropertyStep(
			name <- prop.referredProperty.name,
			nextElement <- prop.getComposite()
		)
}

rule propertyAttBooleanLastInComparison2steps {
	from
		prop : OCL!PropertyCallExp(
			prop.referredProperty.oclIsTypeOf(OCL!EAttribute) and
			prop.referredProperty.eType.oclIsTypeOf(OCL!EDataType) and
			prop.referredProperty.eType.name = 'EBoolean'and
			prop.isLastInComparison()
		)
	to
		pp : Gremlin!PropertyStep(
			name <- prop.referredProperty.name,
			nextElement <- transform
		),
		transform : Gremlin!TransformStep(
			closure <- clos,
			nextElement <- nextCall
		),
		clos : Gremlin!Closure(
			instructions <- eq
		),
		eq : Gremlin!EqualityExpression(
			left <- closureIt,
			right <- bool
		),
		closureIt : Gremlin!ClosureIt(
			
		),
		bool : Gremlin!StringLiteral(
			value <- 'true'
		),
		nextCall : Gremlin!NextCall(
			nextElement <- prop.getComposite()	
		)
}

-- Match OCL StringLiteral expressions to Gremlin StringLiteral
rule oclString2gremlinString {
	from
		oclStringLit : OCL!StringLiteralExp
	to
		gremlinStringLit : Gremlin!StringLiteral(
			value <- oclStringLit.stringSymbol	
		)
}

rule oclPositiveInteger2gremlinInteger {
	from
		oclIntLit : OCL!IntegerLiteralExp (
			if oclIntLit.refImmediateComposite().oclIsTypeOf(OCL!OperationCallExp) then
				not(oclIntLit.refImmediateComposite().getOpName() = '-')
			else
				true
			endif
		)
	to
		gremlinIntLit : Gremlin!IntegerLiteral(
			value <-  oclIntLit.integerSymbol
		)
}

rule oclNegativeInteger2gremlinInteger {
	from
		oclIntLit : OCL!IntegerLiteralExp (
			if oclIntLit.refImmediateComposite().oclIsTypeOf(OCL!OperationCallExp) then
				oclIntLit.refImmediateComposite().getOpName() = '-'
			else
				false
			endif	
		)
	to
		gremlinIntLit : Gremlin!IntegerLiteral(
			value <- 0-oclIntLit.integerSymbol	
		)
}

rule oclPositiveReal2gremlinDouble {
	from
		oclRealLit : OCL!RealLiteralExp (
			if oclRealLit.refImmediateComposite().oclIsTypeOf(OCL!OperationCallExp) then
				not(oclRealLit.refImmediateComposite().getOpName() = '-')
			else
				true
			endif
		)
	to
		gremlinDoubleLit : Gremlin!DoubleLiteral(
			value <- oclRealLit.realSymbol
		)
}

rule oclNegativeReal2gremlinDouble {
	from
		oclRealLit : OCL!RealLiteralExp (
			if oclRealLit.refImmediateComposite().oclIsTypeOf(OCL!OperationCallExp) then
				oclRealLit.refImmediateComposite().getOpName() = '-'
			else
				false
			endif	
		)
	to
		gremlinDoubleLit : Gremlin!DoubleLiteral(
			value <- 0-oclRealLit.realSymbol
		)
}

rule oclBoolean2gremlinBoolean {
	from
		oclBoolean : OCL!BooleanLiteralExp
	to
		gremlinBoolLit : Gremlin!BooleanLiteral(
			value <- oclBoolean.booleanSymbol	
		)
}

-- asSequence oepration are ignored because Gremlin default collection is List, which corresponds
-- to the Sequence concept.
rule oclAsSequence2steps {
	from
		asSequence : OCL!OperationCallExp(asSequence.getOpName() = 'asSequence')
	to
		ip : Gremlin!IdentityStep(
			nextElement <- asSequence.getComposite()
		)
}

-- handle asSequence operation as part of a collection operation
rule oclAsSequenceCol2steps extends oclAsSequence2steps {
	from
		asSequence : OCL!OperationCallExp (asSequence.isLastInUnion())
	to
		ip : Gremlin!IdentityStep(
			nextElement <- fill	
		),
		fill : Gremlin!FillStep(
			instruction <- va	
		),
		va : Gremlin!VariableAccess(
			name <- asSequence.getUnionVariableName()	
		)
}


-- MogwaÃ¯ v0.1 handles Bags and Sequences using a List, so the cast is ignored for Bags as well as Sequences
rule oclAsBag2steps {
	from
		asBag : OCL!OperationCallExp(asBag.getOpName() = 'asBag')
	to
		ip : Gremlin!IdentityStep(
			nextElement <- asBag.getComposite()	
		)
}

-- handle asBag oepration as part of a collection operation
rule oclAsBagCol2steps extends oclAsBag2steps {
	from
		asBag : OCL!OperationCallExp (asBag.isLastInUnion())
	to
		ip : Gremlin!IdentityStep(
			nextElement <- fill	
		),
		fill : Gremlin!FillStep(
			instruction <- va	
		),
		va : Gremlin!VariableAccess(
			name <- asBag.getUnionVariableName()	
		)
}

rule oclAsSet2steps {
	from
		asSet : OCL!OperationCallExp(asSet.getOpName() = 'asSet')
	to
		gather : Gremlin!GatherStep(
			nextElement <- transform
		),
		transform : Gremlin!TransformStep(
			closure <- cl,
			nextElement <- scatter
		),
		cl : Gremlin!Closure(
			instructions <- it	
		),
		it : Gremlin!ClosureIt(
			cast <- setCast	
		),
		setCast : Gremlin!SetDeclaration(),
		scatter : Gremlin!ScatterStep(
			nextElement <- asSet.getComposite()	
		)
}

-- handle asSet operation as part of a collection operation
rule oclAsSetCol2steps extends oclAsSet2steps {
	from
		asSet : OCL!OperationCallExp(asSet.isLastInUnion())
	to
		gather : Gremlin!GatherStep(),
		transform : Gremlin!TransformStep(),
		cl : Gremlin!Closure(),
		it : Gremlin!ClosureIt(),
		setCast : Gremlin!SetDeclaration(),
		scatter : Gremlin!ScatterStep(
			nextElement <- fill	
		),
		fill : Gremlin!FillStep(
			instruction <- va	
		),
		va : Gremlin!VariableAccess(
			name <- asSet.getUnionVariableName()	
		)
}

rule oclAsOrderedSet2steps {
	from
		asOrderedSet : OCL!OperationCallExp(asOrderedSet.getOpName() = 'asOrderedSet')
	to
		gather : Gremlin!GatherStep(
			nextElement <- transform
		),
		transform : Gremlin!TransformStep(
			closure <- cl,
			nextElement <- scatter
		),
		cl : Gremlin!Closure(
			instructions <- it	
		),
		it : Gremlin!ClosureIt(
			cast <- sortedSetCast	
		),
		sortedSetCast : Gremlin!SortedSetDeclaration(),
		scatter : Gremlin!ScatterStep(
			nextElement <- asOrderedSet.getComposite()	
		)
}

-- handle asOrderedSet operation as part of a collection operation
rule oclAsOrderedSetCol2steps extends oclAsOrderedSet2steps {
	from
		asOrderedSet : OCL!OperationCallExp(asOrderedSet.isLastInUnion())
	to
		gather : Gremlin!GatherStep(),
		transform : Gremlin!TransformStep(),
		cl : Gremlin!Closure(),
		it : Gremlin!ClosureIt(),
		sortedSetCast : Gremlin!SortedSetDeclaration(),
		scatter : Gremlin!ScatterStep(
			nextElement <- fill	
		),
		fill : Gremlin!FillStep(
			instruction <- va	
		),
		va : Gremlin!VariableAccess(
			name <- asOrderedSet.getUnionVariableName()	
		)
}

rule oclFirst2steps {
	from
		oclFirst : OCL!OperationCallExp(oclFirst.getOpName() = 'first')
	to
		fc : Gremlin!FirstCall(
			nextElement <- oclFirst.getComposite()
		)
}


rule sequence2steps {
	from
		sequence : OCL!CollectionLiteralExp (sequence.eType.oclIsTypeOf(OCL!SequenceType) and sequence.getComposite() = OclUndefined)
	to
		col : Gremlin!CollectionDefinition(
			values <- sequence.part->collect(e | e.item),
			type <- listDecl
		),
		listDecl : Gremlin!ListDeclaration()
}

-- handle sequence declaration as part of a collection operation
rule sequenceCol2steps extends sequence2steps {
	from 
		sequence : OCL!CollectionLiteralExp (sequence.isLastInUnion())
	to
		col : Gremlin!CollectionDefinition(
			nextElement <- id	
		),
		id : Gremlin!IdentityStep(
			nextElement <- fill	
		),
		fill : Gremlin!FillStep(
			instruction <- va
		),
		va : Gremlin!VariableAccess(
			name <- sequence.getUnionVariableName()
		)
}

rule set2steps {
	from
		set : OCL!CollectionLiteralExp (set.eType.oclIsTypeOf(OCL!SetType) and set.getComposite() = OclUndefined)
	to
		col : Gremlin!CollectionDefinition(
			values <- set.part->collect(e | e.item),
			type <- setDecl
		),
		setDecl : Gremlin!SetDeclaration()
}

-- handle set declaration as part of a collection operation
rule setCol2steps extends set2steps {
	from
		set : OCL!CollectionLiteralExp (set.isLastInUnion())
	to
		col : Gremlin!CollectionDefinition(
			nextElement <- id	
		),
		id : Gremlin!IdentityStep(
			nextElement <- fill	
		),
		fill : Gremlin!FillStep(
			instruction <- va	
		),
		va : Gremlin!VariableAccess(
			name <- set.getUnionVariableName()	
		)
}

rule orderedSet2steps {
	from
		orderedSet : OCL!CollectionLiteralExp (orderedSet.eType.oclIsTypeOf(OCL!OrderedSetType) and orderedSet.getComposite() = OclUndefined)
	to
		col : Gremlin!CollectionDefinition(
			values <- orderedSet.part->collect(e | e.item),
			type <- sortedSetDecl
		),
		sortedSetDecl : Gremlin!SortedSetDeclaration()
}

-- handle ordered set declaration as part of a collection operation
rule orderedSetCol2steps extends orderedSet2steps {
	from
		orderedSet : OCL!CollectionLiteralExp (orderedSet.isLastInUnion())
	to
		col : Gremlin!CollectionDefinition(
			nextElement <- id	
		),
		id : Gremlin!IdentityStep(
			nextElement <- fill	
		),
		fill : Gremlin!FillStep(
			instruction <- va
		),
		va : Gremlin!VariableAccess(
			name <- orderedSet.getUnionVariableName()	
		)
}

rule bag2steps {
	from
		bag : OCL!CollectionLiteralExp (bag.eType.oclIsTypeOf(OCL!BagType) and bag.getComposite() = OclUndefined)
	to
		col : Gremlin!CollectionDefinition(
			values <- bag.part->collect(e | e.item),
			type <- listDecl
		),
		listDecl : Gremlin!ListDeclaration()
}

-- handle bag declaration as part of a collection operation
rule bagCol2steps extends bag2steps {
	from
		bag : OCL!CollectionLiteralExp (bag.isLastInUnion())
	to
		col : Gremlin!CollectionDefinition(
			nextElement <- id	
		),
		id : Gremlin!IdentityStep(
			nextElement <- fill	
		),
		fill : Gremlin!FillStep(
			instruction <- va	
		),
		va : Gremlin!VariableAccess(
			name <- bag.getUnionVariableName()	
		)
}

rule sequenceInChain2steps {
	from
		sequence : OCL!CollectionLiteralExp (sequence.eType.oclIsTypeOf(OCL!SequenceType) and sequence.getComposite() <> OclUndefined)
	to
		col : Gremlin!CollectionDefinition(
			values <- sequence.part->collect(e | e.item),
			type <- listDecl,
			nextElement <- idStep
		),
		listDecl : Gremlin!ListDeclaration(),
		idStep : Gremlin!IdentityStep(
			nextElement <- sequence.getComposite()
		)
}

rule setInChain2steps {
	from
		set : OCL!CollectionLiteralExp (set.eType.oclIsTypeOf(OCL!SetType) and set.getComposite() <> OclUndefined)
	to
		col : Gremlin!CollectionDefinition(
			values <- set.part->collect(e | e.item),
			type <- setDecl,
			nextElement <- idStep
		),
		setDecl : Gremlin!SetDeclaration(),
		idStep : Gremlin!IdentityStep(
			nextElement <- set.getComposite()
		)
}

rule orderedSetInChain2steps {
	from
		orderedSet : OCL!CollectionLiteralExp (orderedSet.eType.oclIsTypeOf(OCL!OrderedSetType) and orderedSet.getComposite() <> OclUndefined) 
	to
		col : Gremlin!CollectionDefinition(
			values <- orderedSet.part->collect(e | e.item),
			type <- sortedSetDecl,
			nextElement <- idStep
		),
		sortedSetDecl : Gremlin!SortedSetDeclaration(),
		idStep : Gremlin!IdentityStep(
			nextElement <- orderedSet.getComposite()	
		)
}

rule bagInChain2steps{
	from
		bag : OCL!CollectionLiteralExp (bag.eType.oclIsTypeOf(OCL!BagType) and bag.getComposite() <> OclUndefined)
	to
		col : Gremlin!CollectionDefinition(
			values <- bag.part->collect(e | e.item),
			type <- listDecl,
			nextElement <- idStep
		),
		listDecl : Gremlin!ListDeclaration(),
		idStep : Gremlin!IdentityStep(
			nextElement <- bag.getComposite()	
		)
}