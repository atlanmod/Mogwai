-- @path ATL=/org.eclipse.m2m.atl.common/org/eclipse/m2m/atl/common/resources/ATL.ecore
-- @path Gremlin=/fr.inria.atlanmod.mogwai.gremlin/model/gremlin.ecore
-- @path SourceEcore=/org.eclipse.emf.ecore/model/Ecore.ecore
-- @path TargetEcore=/org.eclipse.emf.ecore/model.Ecore.ecore

module atl2gremlin;

create OUT: Gremlin from IN: ATL, SOURCEMM:SourceEcore, TARGETMM:TargetEcore;

helper context ATL!Module def: getMatchedRules() : Sequence(ATL!MatchedRule) =
	ATL!MatchedRule.allInstances()->asSequence()
;

-- Get all the types matched by the transformation
-- Note that for now rules matching type tuples are not supported
-- @TODO support rules matching type tuples
helper context ATL!Module def: getMatchedTypes() : Set(ATL!OclModelElement) =
	thisModule.removeDuplicates(
		self.getMatchedRules()
			->collect(e | e.inPattern)
			->collect(e | e.elements->first())
			->collect(e | e.type)
	)
;

-- Get all the types created by the transformation
helper context ATL!Module def: getCreatedTypes() : Set(ATL!OclModelElement) = 
	thisModule.removeDuplicates(
		self.getMatchedRules()
			->collect(e | e.outPattern.elements)->flatten()
			->collect(e | e.type)
	)
;

helper def : removeDuplicates(col : Sequence(ATL!OclModelElement)) : Set(ATL!OclModelElement) =
	col->iterate(e; res: Sequence(ATL!OclModelElement) = Sequence{} |
		if(not(res->collect(x | x.name)->includes(e.name))) then
			res->append(e)
		else
			res
		endif
	)->asSet()
;
	

helper context ATL!MatchedRule def: getMatchedType() : ATL!OclModel =
	self.inPattern.elements->first().type
;

helper context ATL!MatchedRule def: getOclGuard() : ATL!OclExpression =
	self.inPattern.filter
;

helper context ATL!MatchedRule def : getOutTypes() : Sequence(ATL!OclModelElement) =
	self.outPattern.elements->collect(e | e.type)->asSequence()
;

helper context ATL!Binding def : getBindedElement() : String =
	if self.refImmediateComposite().oclIsKindOf(ATL!OutPatternElement) then
		self.refImmediateComposite().varName
	else
		OclUndefined.debug('Cannot find the binded element for ' + self + ' (parent: ' + self.refImmediateComposite() + ')')
	endif
;

helper context ATL!Binding def : getBindedElementClass() : String = 
	if self.refImmediateComposite().oclIsKindOf(ATL!OutPatternElement) then
		self.refImmediateComposite().type.name
	else 
		OclUndefined.debug('Cannot find the binded class for ' + self + 'parent: ' + self.refImmediateComposite() + ')')
	endif
;
	
helper def : getSourceEClassFromString(eClass : String) : SourceEcore!EClass = 
	SourceEcore!EClass.allInstances()->select(cc | cc.name = eClass)->first()
;

-- Returns true if the binding sets an attribute value, false otherwise
-- Note: returning false does not mean the binding sets a reference value, it may also mean that
-- the EStructuralFeature was not found in the source metamodel (it is debugged in that case)
helper context ATL!Binding def : isAttributebinding() : Boolean = 
	let selfClass : SourceEcore!EClass = thisModule.getSourceEClassFromString(self.getBindedElementClass()) in
		let att : SourceEcore!EAttribute = selfClass.eAllAttributes->select(aa | aa.name = self.propertyName)->first() in
			if att.oclIsUndefined() then
				false.debug('Cannot find attribute ' + self.propertyName + ' in EClass ' + selfClass.name)
			else
				true
			endif
;
	
helper context ATL!Binding def : isReferenceBinding() : Boolean =
	let selfClass : SourceEcore!EClass = thisModule.getSourceEClassFromString(self.getBindedElementClass()) in
		let ref : SourceEcore!EReference = selfClass.eAllReferences->select(rr | rr.name = self.propertyName)->first() in
			if ref.oclIsUndefined() then
				false.debug('Cannot find reference ' + self.propertyName + ' in EClass ' + selfClass.name)
			else
				true
			endif
;

rule module2script {
	from 
		mm : ATL!Module
	to
		gg : Gremlin!GremlinScript(
			name <- mm.name,
			instructions <- Sequence{thisModule.module2graphFinalVar(mm)}
				->union(mm.getMatchedTypes()->collect(e | thisModule.oclModel2meta(e)))
				->union(mm.getCreatedTypes()->collect(e | thisModule.oclModel2meta(e)))
				->union(mm.getMatchedTypes()->collect(e | thisModule.oclModel2metaNode(e)))		
				->union(mm.getCreatedTypes()->collect(e | thisModule.oclCreatedModel2metaNode(e))).debug('???????')
				->union(mm.getMatchedRules()).debug('!!!!')
		)
}

-- Creates the final variable containing the graph helper
-- This instruction is needed to make it visible inside closures
lazy rule module2graphFinalVar {
	from
		mm : ATL!Module
	to
		inVar : Gremlin!VariableDeclaration (
			name <- 'gHelper',
			value <- varAccess,
			final <- true
		),
		varAccess : Gremlin!VariableAccess (
			name <- 'graphHelper'	
		)
}

rule matchedRule2transform {
	from
		mm : ATL!MatchedRule
	to
		varAccess : Gremlin!VariableAccess(
			name <- 'meta' + mm.getMatchedType().name + 'Node',
			nextElement <- inE
		),
		inE : Gremlin!InEStep(
			relationshipName <- 'kyanosInstanceOf',
			nextElement <- outV
		),
		outV : Gremlin!OutVStep(
			nextElement <- filter
		),
		filter : Gremlin!FilterStep(
			closure <- clos,
			nextElement <- transform
		),
		clos : Gremlin!Closure(
			instructions <- Sequence{thisModule.createDefForIt(mm.inPattern.elements->first())}.append(mm.getGuardFirstInstruction())
		),
		transform : Gremlin!TransformStep(
			closure <- transformClos	
		),
		transformClos : Gremlin!Closure(
			instructions <- Sequence{}
				.append(thisModule.createDefForIt(mm.inPattern.elements->first()))
				.union(mm.outPattern.elements)
				-- only resolve the first one, resolving others is related to resolveTemp, which is not 
				-- supported yet
				.append(thisModule.createResolveProxyCall(mm))
				.union(mm.outPattern.elements->collect(e | e.bindings))
		)
}

rule outPatternElement2instructions {
	from
		pp : ATL!OutPatternElement
	to
		var : Gremlin!VariableDeclaration (
			name <- pp.varName,
			value <- gHelperAccess
		),
		gHelperAccess: Gremlin!VariableAccess (
			name <- 'gHelper',
			nextElement <- createCall
		),
		createCall : Gremlin!CustomMethodCall (
			name <- 'createElement',
			-- TODO multiple out types
			params <- metaVarAccess
		),
		metaVarAccess : Gremlin!VariableAccess (
			name <- 'meta' + pp.type.name + 'Node'	
		)
}

rule attributeBinding2instruction {
	from
		bb : ATL!Binding (bb.isAttributebinding())
	to
		vaAccess : Gremlin!VariableAccess (
			name <- bb.getBindedElement(),
			nextElement <- prop
		),
		prop : Gremlin!PropertyStep(
			name <- bb.propertyName,
			value <- bb.value.debug('binding value?').getFirstInstruction()
		)
}

rule referenceBinding2instruction {
	from
		bb : ATL!Binding (bb.isReferenceBinding())
	to
		-- Generate the ternary operation that creates the link / plink
		gAccess : Gremlin!VariableAccess (
			name <- 'gHelper',
			nextElement <- linkRefCall
		),
		linkRefCall : Gremlin!CustomMethodCall (
			name <- 'linkReference',
			params <- Sequence{bindedElVarAccess, bb.value.getFirstInstruction(), propSR}
		),
		bindedElVarAccess : Gremlin!VariableAccess (
			name <- bb.getBindedElement()	
		),
		propSR : Gremlin!StringLiteral (
			value <- bb.propertyName	
		)
}

helper def : gremlinToString(input : Gremlin!Instruction) : String = 
	input.oclType().debug()
;


lazy rule createDefForIt {
	from
		ss : ATL!SimpleInPatternElement
	to
		dd : Gremlin!VariableDeclaration(
			name <- ss.varName,
			value <- closIt
		),
		closIt : Gremlin!ClosureIt()
}

lazy rule createResolveProxyCall {
	from
		mm : ATL!MatchedRule
	to
		gHelperAccess : Gremlin!VariableAccess (
			name <- 'gHelper',
			nextElement <- resProxyCall
		),
		resProxyCall : Gremlin!CustomMethodCall (
			name <- 'resolveProxies',
			params <- Sequence{sourceVarAccess, targetVarAccess}
		),
		sourceVarAccess : Gremlin!VariableAccess (
			name <- mm.inPattern.elements->first().varName	
		),
		targetVarAccess : Gremlin!VariableAccess (
			name <- mm.outPattern.elements->first().varName
		)
}

lazy rule oclModel2meta {
	from
		mm : ATL!OclModelElement
	to
		metaVar : Gremlin!VariableDeclaration (
			name <- 'meta'+mm.name,
			value <- metaStartStep
		),
		metaStartStep : Gremlin!StartStep (
			nextElement <- idxCall	
		),
		idxCall : Gremlin!IndexCall (
			indexName <- 'metaclasses',
			indexProperty  <- 'name',
			indexQuery <- mm.name
		)
}
	
lazy rule oclModel2metaNode {
	from
		mm : ATL!OclModel
	to
		metaVar : Gremlin!VariableDeclaration(
			name <- 'meta'+mm.name+'Node',
			value <- tern
		),
		tern : Gremlin!TernaryOperator(
			condition <- checkVarAccess,
			ifTrue <- okVarAccess,
			ifFalse <- nullLiteral
		),
		checkVarAccess : Gremlin!VariableAccess(
			name <- 'meta' + mm.name,
			nextElement <- checkHasNext
		),
		checkHasNext : Gremlin!HasNextCall(
				
		),
		okVarAccess : Gremlin!VariableAccess(
			name <- 'meta'+mm.name,
			nextElement <- nextIt
		),
		nextIt : Gremlin!NextCall (),
		nullLiteral : Gremlin!NullLiteral()
		
}

-- Creates the meta node if needed
lazy rule oclCreatedModel2metaNode {
	from
		mm : ATL!OclModelElement
	to
		metaVar : Gremlin!VariableDeclaration (
			name <- 'meta'+mm.name + 'Node',
			value <- tern
		),
		tern : Gremlin!TernaryOperator(
			condition <- checkVarAccess,
			ifTrue <- okVarAccess,
			ifFalse <- gHelperAccess
		),
		checkVarAccess : Gremlin!VariableAccess (
			name <- 'meta' + mm.name,
			nextElement <- checkHasNext
		),
		checkHasNext : Gremlin!HasNextCall (
			
		),
		okVarAccess : Gremlin!VariableAccess (
			name <- 'meta' + mm.name,
			nextElement <- nextCall
		),
		nextCall : Gremlin!NextCall (
		
		),
		gHelperAccess : Gremlin!VariableAccess (
			name <- 'gHelper',
			nextElement <- createCall
		),
		createCall : Gremlin!CustomMethodCall (
			name <- 'createMetaclass'
		)
}