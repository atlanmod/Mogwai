-- @path ATL=/org.eclipse.m2m.atl.common/org/eclipse/m2m/atl/common/resources/ATL.ecore
-- @path Gremlin=/fr.inria.atlanmod.mogwai.gremlin/model/gremlin.ecore

module atl2gremlin;

create OUT: Gremlin from IN: ATL;

helper context ATL!Module def: getMatchedRules() : Sequence(ATL!MatchedRule) =
	ATL!MatchedRule.allInstances()->asSequence()
;

-- Get all the types matched by the transformation
-- Note that for now rules matching type tuples are not supported
-- @TODO support rules matching type tuples
helper context ATL!Module def: getMatchedTypes() : Set(ATL!OclModelElement) =
	thisModule.removeDuplicates(
		self.getMatchedRules()
			->collect(e | e.inPattern)
			->collect(e | e.elements->first())
			->collect(e | e.type)
	)
;

-- Get all the types created by the transformation
helper context ATL!Module def: getCreatedTypes() : Set(ATL!OclModelElement) = 
	thisModule.removeDuplicates(
		self.getMatchedRules()
			->collect(e | e.outPattern.elements)->flatten()
			->collect(e | e.type)
	)
;

helper def : removeDuplicates(col : Sequence(ATL!OclModelElement)) : Set(ATL!OclModelElement) =
	col->iterate(e; res: Sequence(ATL!OclModelElement) = Sequence{} |
		if(not(res->collect(x | x.name)->includes(e.name))) then
			res->append(e)
		else
			res
		endif
	)->asSet()
;
	

helper context ATL!MatchedRule def: getMatchedType() : ATL!OclModel =
	self.inPattern.elements->first().type
;

helper context ATL!MatchedRule def: getOclGuard() : ATL!OclExpression =
	self.inPattern.filter
;

helper context ATL!MatchedRule def : getOutTypes() : Sequence(ATL!OclModelElement) =
	self.outPattern.elements->collect(e | e.type)->asSequence()
;
	

rule module2script {
	from 
		mm : ATL!Module
	to
		gg : Gremlin!GremlinScript(
			name <- mm.name,
			instructions <- Sequence{thisModule.module2inFinalVar(mm), thisModule.module2outFinalVar(mm), thisModule.module2tlFinalVar(mm)}
				->union(mm.getMatchedTypes()->collect(e | thisModule.oclModel2meta(e)))
				->union(mm.getCreatedTypes()->collect(e | thisModule.oclModel2meta(e)))
				->union(mm.getMatchedTypes()->collect(e | thisModule.oclModel2metaNode(e)))		
				->union(mm.getCreatedTypes()->collect(e | thisModule.oclCreatedModel2metaNode(e)))
				->union(mm.getMatchedRules())
		)
}

-- Creates the final variable containing the input graph helper
-- This instruction is needed to make it visible inside closures
lazy rule module2inFinalVar {
	from
		mm : ATL!Module
	to
		inVar : Gremlin!VariableDeclaration (
			name <- 'inH',
			value <- varAccess,
			final <- true
		),
		varAccess : Gremlin!VariableAccess (
			name <- 'inHelper'	
		)
}

-- Creates the final variable containing the output graph helper
-- This instruction is needed to make it visible inside closures
lazy rule module2outFinalVar {
	from
		mm : ATL!Module
	to
		outVar : Gremlin!VariableDeclaration (
			name <- 'outH',
			value <- varAccess,
			final <- true
		),
		varAccess : Gremlin!VariableAccess (
			name <- 'outHelper'	
		)
}

-- Creates the final variable containing the trace link manager
-- This instruction is needed to make it visible inside closures
lazy rule module2tlFinalVar {
	from
		mm : ATL!Module
	to
		tlVar : Gremlin!VariableDeclaration (
			name <- 'tlM',
			value <- varAccess,
			final <- true
		),
		varAccess : Gremlin!VariableAccess (
			name <- 'tlManager'	
		)
}

rule matchedRule2transform {
	from
		mm : ATL!MatchedRule
	to
		varAccess : Gremlin!VariableAccess(
			name <- 'meta' + mm.getMatchedType().name + 'Node',
			nextElement <- inE
		),
		inE : Gremlin!InEStep(
			relationshipName <- 'kyanosInstanceOf',
			nextElement <- outV
		),
		outV : Gremlin!OutVStep(
			nextElement <- filter
		),
		filter : Gremlin!FilterStep(
			closure <- clos,
			nextElement <- transform
		),
		clos : Gremlin!Closure(
			instructions <- Sequence{thisModule.createDefForIt(mm.inPattern.elements->first())}.append(mm.inPattern.filter.getFirstInstruction())
		),
		transform : Gremlin!TransformStep(
			closure <- transformClos	
		),
		transformClos : Gremlin!Closure(
			-- TODO handle it, multiple instructions etc
			instructions <- Sequence{}
				.append(thisModule.createDefForIt(mm.inPattern.elements->first()))
				.append(thisModule.createTraceLinkInstruction(mm.inPattern.elements->first()))
				.union(mm.outPattern.elements)
		)
}

rule outPatternElement2instructions {
	from
		pp : ATL!OutPatternElement
	to
		var : Gremlin!VariableDeclaration (
			name <- pp.varName,
			value <- outHelperAccess
		),
		outHelperAccess: Gremlin!VariableAccess (
			name <- 'outHelper',
			nextElement <- createCall
		),
		createCall : Gremlin!CustomMethodCall (
			name <- 'createElement',
			-- TODO multiple out types
			params <- 'meta' + pp.type.name + 'Node'
		)
}

lazy rule createTraceLinkInstruction {
	from
		ss : ATL!SimpleInPatternElement
	to
		tlDecl : Gremlin!VariableDeclaration (
			name <- 'tl',
			value <- tlmAccess
		),
		tlmAccess : Gremlin!VariableAccess (
			name <- 'tlM',
			nextElement <- createCall
		),
		createCall : Gremlin!CustomMethodCall (
			name <- 'createTraceLink',
			params <- Sequence{ss.varName}
		)
}

lazy rule createDefForIt {
	from
		ss : ATL!SimpleInPatternElement
	to
		dd : Gremlin!VariableDeclaration(
			name <- ss.varName,
			value <- closIt
		),
		closIt : Gremlin!ClosureIt()
}

lazy rule oclModel2meta {
	from
		mm : ATL!OclModelElement
	to
		metaVar : Gremlin!VariableDeclaration (
			name <- 'meta'+mm.name,
			value <- metaStartStep
		),
		metaStartStep : Gremlin!StartStep (
			nextElement <- idxCall	
		),
		idxCall : Gremlin!IndexCall (
			indexName <- 'metaclasses',
			indexProperty  <- 'name',
			indexQuery <- mm.name
		)
}
	
lazy rule oclModel2metaNode {
	from
		mm : ATL!OclModel
	to
		metaVar : Gremlin!VariableDeclaration(
			name <- 'meta'+mm.name+'Node',
			value <- tern
		),
		tern : Gremlin!TernaryOperator(
			condition <- checkVarAccess,
			ifTrue <- okVarAccess,
			ifFalse <- nullLiteral
		),
		checkVarAccess : Gremlin!VariableAccess(
			name <- 'meta' + mm.name,
			nextElement <- checkHasNext
		),
		checkHasNext : Gremlin!HasNextCall(
				
		),
		okVarAccess : Gremlin!VariableAccess(
			name <- 'meta'+mm.name,
			nextElement <- nextIt
		),
		nextIt : Gremlin!NextCall (),
		nullLiteral : Gremlin!NullLiteral()
		
}

-- Creates the meta node if needed
lazy rule oclCreatedModel2metaNode {
	from
		mm : ATL!OclModelElement
	to
		metaVar : Gremlin!VariableDeclaration (
			name <- 'meta'+mm.name + 'Node',
			value <- tern
		),
		tern : Gremlin!TernaryOperator(
			condition <- checkVarAccess,
			ifTrue <- okVarAccess,
			ifFalse <- outHelperAccess
		),
		checkVarAccess : Gremlin!VariableAccess (
			name <- 'meta' + mm.name,
			nextElement <- checkHasNext
		),
		checkHasNext : Gremlin!HasNextCall (
			
		),
		okVarAccess : Gremlin!VariableAccess (
			name <- 'meta' + mm.name,
			nextElement <- nextCall
		),
		nextCall : Gremlin!NextCall (
		
		),
		outHelperAccess : Gremlin!VariableAccess (
			name <- 'outHelper',
			nextElement <- createCall
		),
		createCall : Gremlin!CustomMethodCall (
			name <- 'createMetaclass'
		)
}